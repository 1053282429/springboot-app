1.客户端的长轮询任务在NacosFactory.createConfigService构建configService对象实例的时候启动。
2.nacosConfigServie构造方法：初始化一个httpAgent,初始化clientWorker
2.clientWorker构造方法，蛀牙哦是构建两个定时调度的线程池 ， 并启动一个定时任务
第一个线程池executor只有一个核心线程，没10ms执行部一次checkconfiginfo方法。
第二个executorService只完成了初始化，后续用到，主要实现客户端的定时长轮询功能。
checkconfigInfo中cacheMap   用来存储监听变更的混啊村级和，key是dataid、grouop拼接的值，value是对应的nacos服务器上的配置文件内容
长轮询任务拆分  ，每个长轮询任务处理3000个配置项，超过需要拆分成多个任务。
3.longPollingRunnable.run
通过checkLocalConfig方法检查本地配置
执行checkUpdateDataIds方法，在服务端建立长轮询机制，从服务端获取发送变更的数据。
便利变更数据集合changedGroupKeys,调用getServerConfig方法，根据dataid，group拼接key去服务端读取对应的配置信息并保存在本地配置文件中。

longPollingRunnable.run
根据taskid对cachemap进行数据分割，在比较配置文件的数据是否存在变更，如果有变更则直接触发通知。这里要注意，在user/nacos/config目录下会缓存一份服务端的配置信息，checkLoclConfig
会和本地磁盘中的文件内容进行比较，如果内存中的数据和磁盘中的数据不一致说明数据发生了变更，需要触发事件通知
接着调用checkUpdateDataids方法，基于长连接方式来监听服务端配置的变化，最后根据变化数据的key去服务端获取最新数据。checkUpdateDataIds最终会调用checkUpdateConfigStr方法。
checkUpdateConfigStr方法实际上通过agent.http-Post调用/listener接口实现长轮询请求。长轮询在实现层只是设置了一个比较长的超时时间，默认是30s.如果服务端发生了变更，客户端会收到
响应，服务端返回的是存在数据变更的dataid、group，获得这些信息后，在调用getServerConfig去navos服务端读取具体的配置内容


服务端长轮询梳理机制
获取客户端需要监听的可能发生变更的配置，并计算md5值
inner.doPollingConfig开始执行长轮询请求。

首先会判断当前请求是否为长轮询，如果是，调用addLongPollingClient.
获取客户端请求额超时时间，减去500ms后赋值给timeout
判断isFixedPolling,如果为true，定时任务将会在30s后开始，否则29.5s后执行
和服务端的数据进行MD5对比，如果有变化则直接返回。
scheduler.execute执行ClientLongPolling线程。
ClientLongPolling.run
通过scheduler.schedule启动一个定时任务，并且延时时间为29.5s。
将ClientLongPolling实力本身添加到allSubs队列中，他要维护一个长轮询的订阅关系。
定时任务执行后，先把ClientLongPolling实力本身从allSubs队列中移除。
通过MD5比较客户端请求的groupkeys是否发生了变更，并将变更结果通过resp返回给客户端


事件
LongPollingService继承了listener
onEvent方法
DataChangeTask.run
遍历allSubs中的客户端长轮询请求。
比较每一个客户端长轮询请求携带的groupKey，如果服务端变更的配置和客户端请求关注的一致，则直接返回
































































